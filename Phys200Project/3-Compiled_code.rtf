{\rtf1\ansi\ansicpg1252\cocoartf1138\cocoasubrtf230
{\fonttbl\f0\fswiss\fcharset0 Helvetica;}
{\colortbl;\red255\green255\blue255;}
\margl1440\margr1440\vieww10800\viewh8400\viewkind0
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural

\f0\fs24 \cf0 import random\
import time\
class Car(object):\
	"""does car things"""\
	#initializes the car\
	def __init__(self,pos=0, vmax = 0, p=0, cruise_control=False):\
		self.pos = pos\
		self.vmax = vmax\
		self.v = random.randint(0, self.vmax)\
		self.p = p\
		self.cruise_control = cruise_control\
	#checks how many spaces are in front	\
	def check_front(array):\
		arr = array\
		i=1\
		while pos+i <= len(arr):\
			#checks if the car leaves the array\
			if pos+i >= len(arr):\
				if arr[0] == 0:\
					self.pos = 0\
					return i + check_front()\
				else:\
					return len(arr)\
			#+1 to empty space count\
			elif arr[pos+1] == 0:\
				i = i+1\
			#returns number of empty spaces ahead of it\
			else:\
				return pos+i-1\
	#makes v\
	def check_velocity(array):\
		arr = array\
		#sets v = to g\
		if self.v > check_front(arr) or self.v < check_front(arr):\
			self.v = self.g\
			#random chance of reducing speed\
			if self.p > random() and self.v != self.vmax and cruise_control==True:\
				self.v = self.v - 1\
				return self.v\
			else:\
				return self.v\
		else:\
			if self.p > random() and self.v != self.vmax and cruise_control==True:\
				self.v = self.v - 1\
				return self.v\
			else:\
				return self.v\
	#returns the new position\
	def move_car(array):\
		arr = array\
		x = self.pos + check_velocity(arr)\
		#checks is the new position is greater than the length of the array and loops the car through\
		if x >= len(arr):\
			return x - len(arr)\
		else:\
			return x\
	def set_velocity(array):\
		arr = array\
		self.v = check_velocity(arr)\
\
\
import pylab as pylab\
import numpy as np\
import matplotlib as mat\
import matplotlib.pyplot as plt\
\
# So Tristan is going to give me an array and for now I'm going to assume\
# that it looks like this: [name position] and that each column is a number\
# of cars long.\
def visualize(x,y):\
    numcar = x[:]  # number of cars\
    position = y[:]  # position as an integer\
    if len(numcar) == 1:\
        fig = plt.figure()\
        ax1 = fig.add_subplot(111)\
        t = np.arange(0.01,100,1)\
        car1 = (position[0])\
        ax1.plot(car1,1,'bo')\
        ax1.set_xlabel('distance')\
        pylab.grid(True)\
        pylab.xlim([0.01,100])\
        pylab.show()\
    elif len(numcar) == 2:\
    	fig = plt.figure()\
        ax1 = fig.add_subplot(111)\
        t = np.arange(0.01,100,1)\
        car1 = (position[0])\
        ax1.plot(car1,1,'bo')\
        ax1.set_xlabel('distance')\
        ax2 = fig.add_subplot(111)\
        car2 = (position[1])\
        ax2.plot(car2,1,'ro')\
        pylab.grid(True)\
        pylab.xlim([0.01,100])\
        pylab.show()\
    elif len(numcar) == 3:\
        fig = plt.figure()\
        ax1 = fig.add_subplot(111)\
        t = np.arange(0.01,100,1)\
        car1 = (position[0])\
        ax1.plot(car1,1,'bo')\
        ax1.set_xlabel('distance')\
        ax2 = fig.add_subplot(111)\
        car2 = (position[1])\
        ax2.plot(car2,1,'ro')\
        ax3 = fig.add_subplot(111)\
        car3 = (position[2])\
        ax3.plot(car3,1,'go')\
        pylab.grid(True)\
        pylab.xlim([0.01,100])\
        pylab.show()\
    elif len(numcar) == 4:\
        fig = plt.figure()\
        ax1 = fig.add_subplot(111)\
        t = np.arange(0.01,100,1)\
        car1 = (position[0])\
        ax1.plot(car1,1,'bo')\
        ax1.set_xlabel('distance')\
        ax2 = fig.add_subplot(111)\
        car2 = (position[1])\
        ax2.plot(car2,1,'ro')\
        ax3 = fig.add_subplot(111)\
        car3 = (position[2])\
        ax3.plot(car3,1,'go')\
        ax4 = fig.add_subplot(111)\
        car4 = (position[3])\
        ax4.plot(car4,1,'mo')\
        pylab.grid(True)\
        pylab.xlim([0.01,100])\
        pylab.show()\
    elif len(numcar) == 5:\
        fig = plt.figure()\
        ax1 = fig.add_subplot(111)\
        t = np.arange(0.01,100,1)\
        car1 = (position[0])\
        ax1.plot(car1,1,'bo')\
        ax1.set_xlabel('distance')\
        ax2 = fig.add_subplot(111)\
        car2 = (position[1])\
        ax2.plot(car2,1,'ro')\
        ax3 = fig.add_subplot(111)\
        car3 = (position[2])\
        ax3.plot(car3,1,'go')\
        ax4 = fig.add_subplot(111)\
        car4 = (position[3])\
        ax4.plot(car4,1,'mo')\
        ax5 = fig.add_subplot(111)\
        car5 = (position[4])\
        ax5.plot(car5,1,'yo')\
        pylab.grid(True)\
        pylab.xlim([0.01,100])\
        pylab.show()\
    \
\
def Porj( NumberCar, NumberStep):\
    numStep = NumberStep #number of steps, change to user input\
    numCar = NumberCar\
    density = []\
    #error = 'Wrong input, try again.'\
    #while (numCar <= 20) and (numCar > 0): #first positions, random non-repeating\
    #    print 'Enter number of cars (from 1 to 20): '\
    #    numCar = raw_input()\
    #    if (numCar < 20) or (numcar >1):\
    #        print error\
    lenRoad = 20 #number of spaces on road\
    curRoad = [] #the current road, a list of car objects\
    c = 0\
    n = 0\
    import copy\
    q = 0\
    initalPos = []\
    while q < numCar:\
        rad = random.randint(0, 100)\
        if rad not in initalPos:\
            initalPos.append(rad)\
            q += 1\
    while c < numCar: #creates initial road\
        curRoad.append(Car())\
        c += 1\
    while n < numStep:#This will visualize the current road and make a new one\
        newRoad = [] #road to be made, will replaces curRoad\
        posLis = []\
        namLis = []\
        index = 1\
        firstPos = 101\
        lastPos = -1\
        for b in curRoad: #makes list for visualization\
            posLis.append(b.pos)\
            if(b.pos < firstPos):\
                firstPos = b.pos\
            if(b.pos > lastPos):\
                lastPos = b.pos\
            namLis.append(index)\
            index += 1\
        density.append( numCar/(0.1+lastPos - firstPos) ) #density of step\
        visualize(namLis, posLis) #Visualizes current road\
        street = [0]*(lenRoad+1)\
        for a in curRoad:#also maybe use to get density\
            street[a.pos] = 1\
	print 'street',street\
        for car in curRoad:#here is the major part I need to finish\
            newCar = copy.copy(car)\
            newCar.pos = car.move_car(street)\
            newRoad.append(newCar) #adds the new car to the new road\
        curRoad = newRoad\
        print 'To contiue, press enter.'\
        time.sleep(1)\
        n += 1}